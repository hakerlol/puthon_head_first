import argparse
import collections
import logging
import pathlib
import sys
import time
import typing

import pkg_resources

import odd
from odd.plugin import Plugin
from odd.const import DEFAULT_MAX_LEVELS_UP, SUPPORTED_ODOO_VERSIONS
from odd.artifact import Addon, Confidence, Issue, Severity, Artifact
from odd.addon_utils import discover_addons
from odd.utils import filter_issues, format_issue_locations

_LOG = logging.getLogger(__name__)
ArtifactType = typing.Type[Artifact]


class KeepReturnValueGenerator:
    """Credit: https://stackoverflow.com/a/34073559"""

    def __init__(self, gen: typing.Generator):
        self.gen, self.return_value = gen, None

    def __iter__(self):
        self.return_value = yield from self.gen


class _EnumCountAction(argparse.Action):
    """
    :class:`argparse.Action` which is similar to `action="count"` but is tied
    to an :class:`enum.Enum`.
    """

    def __init__(self, option_strings, dest, enum, required=False, help=None):
        self._enum = enum
        self._enum_vals = [
            member for name, member in enum.__members__.items() if member.name == name
        ]
        self._count = 0
        super().__init__(
            option_strings=option_strings,
            dest=dest,
            nargs=0,
            default=0,
            required=required,
            help=help,
        )

    def __call__(self, parser, namespace, values, option_string=None):
        self._count += 1
        if self._count > len(self._enum):
            raise argparse.ArgumentError(
                self,
                f"{self._enum} is limited to {len(self._enum):d} "
                f"(got >= {self._count:d})",
            )
        setattr(namespace, self.dest, self._enum_vals[self._count - 1])


def get_plugins(
    whitelist: typing.Optional[typing.Iterable[str]] = None,
) -> typing.Dict[str, typing.Type[Plugin]]:
    whitelist = set([] if whitelist is None else whitelist)
    use_whitelist = bool(whitelist)
    plugins: typing.Dict[str, typing.Type[Plugin]] = collections.OrderedDict()
    for entry_point in pkg_resources.iter_entry_points("odd.plugin"):
        plugin_name = entry_point.name
        if whitelist and plugin_name not in whitelist:
            continue
        try:
            plugin_cls = entry_point.load()
        except Exception:  # pylint: disable=broad-except
            _LOG.exception('An error occurred while loading plugin "%s".', plugin_name)
        else:
            plugins[plugin_name] = plugin_cls
        finally:
            whitelist.discard(plugin_name)
            if use_whitelist and not whitelist:
                break

    for plugin_name in whitelist:
        raise KeyError(f'Plugin "{plugin_name}" not found.')

    return plugins


def get_artifact_types() -> typing.Dict[str, typing.Type[Artifact]]:
    return {
        ep.name: ep.load() for ep in pkg_resources.iter_entry_points("odd.artifact")
    }


def check_addon(
    addon: Addon,
    plugins: typing.Mapping[str, typing.Type[Plugin]],
    *,
    yield_classinfo: typing.Union[ArtifactType, typing.Tuple[ArtifactType]] = (Issue,),
) -> typing.Generator[Artifact, None, bool]:
    artifact_types = get_artifact_types()
    artifact_type_inverse = {cls_: name for name, cls_ in artifact_types.items()}
    emitters: typing.Dict[str, typing.List[str]] = collections.defaultdict(list)
    handlers: typing.Dict[str, typing.List[str]] = collections.defaultdict(list)
    plugin_instances = {}

    for plugin_name, plugin_cls in plugins.items():
        load = True
        for emit in plugin_cls._emits:
            if emit not in artifact_types:
                _LOG.error(
                    "Plugin: %s emits unknown artifact type: %s. "
                    "The plugin will not be loaded.",
                    plugin_name,
                    emit,
                )
                load = False
                break
            else:
                emitters[emit].append(plugin_name)

        if not load:
            continue

        for handle in plugin_cls._handles:
            if handle not in artifact_types:
                _LOG.warning(
                    "Plugin: %s handles unknown artifact type: %s.", plugin_name, handle
                )
            else:
                handlers[handle].append(plugin_name)

        if load:
            plugin_instances[plugin_name] = plugin_cls()

    # TODO: Validate plugin types.

    success = True
    artifacts: typing.Deque[Artifact] = collections.deque([addon])

    def _handle_artifact(
        artifact: Artifact, plugin_name: str, collect: bool = True
    ) -> typing.Iterator[Artifact]:
        if isinstance(artifact, yield_classinfo):
            yield artifact
        if isinstance(artifact, Artifact):
            if collect:
                artifacts.append(artifact)
        else:
            _LOG.warning(
                "Unknown result type (%s) received from plugin: %s",
                type(artifact),
                plugin_name,
            )

    def _run_handler(
        func: typing.Callable,
        plugin_name: str,
        artifact: Artifact,
        collect_artifacts: bool = True,
    ) -> typing.Iterator[Artifact]:
        nonlocal success
        gen = func(artifact)
        while True:
            try:
                new_artifact = next(gen)
            except StopIteration:
                break
            except Exception:
                success = False
                _LOG.exception(
                    'An unexpected error occurred while plugin "%s" was handling '
                    "artifact: %s:",
                    plugin_name,
                    artifact,
                )
            else:
                yield from _handle_artifact(
                    new_artifact, plugin_name, collect=collect_artifacts
                )

    while artifacts:
        artifact = artifacts.popleft()
        artifact_type_name = artifact_type_inverse[type(artifact)]

        for plugin_name in handlers[artifact_type_name]:
            plugin = plugin_instances[plugin_name]
            yield from _run_handler(
                getattr(plugin, f"on_{artifact_type_name}"), plugin_name, artifact
            )

    for plugin_name, plugin in plugin_instances.items():
        if hasattr(plugin, "on_after"):
            # Do not collect new artifacts, since no further processing will be
            # done, only allow `yield_classinfo` instances to pass through.
            yield from _run_handler(
                plugin.on_after, plugin_name, addon, collect_artifacts=False
            )

    # We should've handled all the artifacts at this point.
    if artifacts:
        raise AssertionError("Expected all artifacts to be consumed")

    return success


def main(argv=None):
    parser = argparse.ArgumentParser(prog="odd", description=odd.__doc__)
    parser.add_argument(
        "odoo_version",
        metavar="ODOO_VERSION",
        type=int,
        choices=SUPPORTED_ODOO_VERSIONS,
        help="version of Odoo the addon(s) are written for",
    )
    parser.add_argument(
        "paths",
        metavar="PATH",
        type=pathlib.Path,
        nargs="+",
        help=(
            "path(s) of directories to scan for Odoo addons. odd understands an addon "
            "to be a directory with an Odoo manifest file directly inside it. If the "
            "%(metavar)s is a file, odd will try to find the addon it belongs to by "
            "going a maximum of --max-levels-up directory levels up"
        ),
    )
    parser.add_argument(
        "--max-levels-up",
        metavar="N",
        type=int,
        default=DEFAULT_MAX_LEVELS_UP,
        help=(
            "maximum number of directory levels to go up when looking for a manifest "
            "file. Changing it only makes sense when PATH points to a file. "
            "Default: %(default)d"
        ),
    )
    parser.add_argument(
        "--only-installable",
        dest="allow_not_installable",
        help="ignore addons which are not installable",
        action="store_false",
    )
    parser.add_argument(
        "-l",
        "--level",
        dest="min_severity",
        action=_EnumCountAction,
        enum=Severity,
        help="report only issues of a given severity level or higher "
        "(-l for INFO, -ll for NORMAL, -lll for MAJOR)",
    )
    parser.add_argument(
        "-i",
        "--confidence",
        dest="min_confidence",
        action=_EnumCountAction,
        enum=Confidence,
        help="report only issues of a given confidence level or "
        "higher (-i for LOW, -ii for MEDIUM, -iii for HIGH)",
    )
    parser.add_argument(
        "--version", action="version", version=f"%(prog)s {odd.__version__}"
    )
    parser.add_argument(
        "--debug",
        dest="loglevel",
        action="store_const",
        const=logging.DEBUG,
        help="output debugging messages",
        default=logging.INFO,
    )
    parser.add_argument(
        "-w",
        "--whitelist",
        metavar="PLUGIN_NAME",
        nargs="*",
        help="only load plugins which are specified (space-separated)",
    )

    args = parser.parse_args(sys.argv[1:] if argv is None else argv)

    logging.basicConfig(level=args.loglevel)

    cwd = pathlib.Path.cwd()
    plugins = get_plugins(whitelist=args.whitelist)
    success = True
    # NOTE FIXME: If more than one file path (not directory) is given, the full addon
    # check will be done for each file.
    for path in args.paths:
        for addon in discover_addons(
            path, args.odoo_version, allow_not_installable=args.allow_not_installable
        ):
            _LOG.debug("Checking addon: %s at path: %s", addon.name, addon.path)
            t0 = time.time()
            check_gen = KeepReturnValueGenerator(check_addon(addon, plugins))
            for issue in filter_issues(
                check_gen,
                min_severity=args.min_severity,
                min_confidence=args.min_confidence,
            ):
                for line in format_issue_locations(
                    issue, cwd, fixed_path=path if path.is_file() else None
                ):
                    print(line)
                    success = False

            if success:
                success = check_gen.return_value

            _LOG.debug("Checking addon: %s took %.2fs", addon.name, time.time() - t0)

    parser.exit(
        status=not success,
        message="That's odd, no issues were found" if success else None,
    )
