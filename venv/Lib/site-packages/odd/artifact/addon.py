import ast
import dataclasses
import itertools
import pathlib
import typing

from ..const import MANIFEST_DATA_KEYS, MANIFEST_DEMO_KEYS
from ._base import Artifact


@dataclasses.dataclass(unsafe_hash=True)
class Addon(Artifact):
    manifest_path: pathlib.Path
    manifest: typing.Dict[str, typing.Any]
    odoo_version: int

    @property
    def path(self) -> pathlib.Path:
        return self.manifest_path.parent

    @property
    def name(self) -> str:
        return self.path.name

    @property
    def data_files(self) -> typing.List[pathlib.Path]:
        return [
            self.path / fn
            for fn in itertools.chain(
                *((self.manifest.get(k) or []) for k in MANIFEST_DATA_KEYS)
            )
        ]

    @property
    def demo_files(self) -> typing.List[pathlib.Path]:
        return [
            self.path / fn
            for fn in itertools.chain(
                *((self.manifest.get(k) or []) for k in MANIFEST_DEMO_KEYS)
            )
        ]

    @property
    def qweb_files(self) -> typing.List[pathlib.Path]:
        files: typing.List[pathlib.Path] = []
        for fn in self.manifest.get("qweb") or []:
            fn_path = self.path / fn
            if "*" in fn_path.stem:
                files.extend(fn_path.parent.glob(fn_path.name))
            else:
                files.append(fn_path)
        return files

    @classmethod
    def from_manifest_path(
        cls, manifest_path: pathlib.Path, odoo_version: int
    ) -> "Addon":
        return cls(manifest_path, parse_manifest(manifest_path), odoo_version)


@dataclasses.dataclass
class AddonPath(Artifact):
    addon: Addon
    path: pathlib.Path


@dataclasses.dataclass
class DataFile(AddonPath):
    ...


@dataclasses.dataclass
class DemoFile(AddonPath):
    ...


def parse_manifest(manifest_path: pathlib.Path) -> typing.Any:
    with manifest_path.open(mode="r") as f:
        # FIXME: Check for manifest file size.
        return ast.literal_eval(f.read())
