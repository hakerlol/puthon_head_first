import ast
import typing

from odd.artifact.issue import Position
from odd.const import UNKNOWN

_BODY_NODES = (
    ast.AsyncFor,
    ast.AsyncFunctionDef,
    ast.AsyncWith,
    ast.ClassDef,
    ast.For,
    ast.FunctionDef,
    ast.If,
    ast.Interactive,
    ast.Module,
    ast.Suite,
    ast.Try,
    ast.While,
    ast.With,
)

BodyNode = typing.Union[
    ast.AsyncFor,
    ast.AsyncFunctionDef,
    ast.AsyncWith,
    ast.ClassDef,
    ast.For,
    ast.FunctionDef,
    ast.If,
    ast.Interactive,
    ast.Module,
    ast.Suite,
    ast.Try,
    ast.While,
    ast.With,
]

ASTNodeType = typing.Type[ast.AST]
T_AST = typing.TypeVar("T_AST", bound=ast.AST)


def _column_index_1(position: Position) -> Position:
    return position._replace(
        column=position[1] if position[1] is None else position[1] + 1
    )


class ASTNodePosition(typing.NamedTuple):
    start_pos: Position
    end_pos: Position

    @property
    def start_pos_col_1(self) -> Position:
        return _column_index_1(self.start_pos)

    @property
    def end_pos_col_1(self) -> Position:
        return _column_index_1(self.end_pos)

    @classmethod
    def from_node(cls, node: ast.AST) -> "ASTNodePosition":
        return cls(
            Position(node.lineno, node.col_offset),
            Position(node.end_lineno, node.end_col_offset),
        )


def search_in_scope(
    node: BodyNode,
    node_classinfo: typing.Union[
        typing.Type[T_AST], typing.Tuple[typing.Type[T_AST], ...]
    ],
) -> typing.Iterator[T_AST]:
    def scan(body: typing.Sequence[ast.stmt]):
        for el in body:
            if isinstance(el, node_classinfo):
                yield el
            if isinstance(el, _BODY_NODES):
                yield from scan(el.body)

    return scan(node.body)


def parse(
    odoo_version: int,
    source: typing.Union[str, bytes],
    filename: typing.Union[str, bytes] = "<unknown>",
    type_comments: bool = False,
) -> ast.Module:
    feature_version = (3, 6) if odoo_version >= 13 else (3, 5)
    return ast.parse(
        source,
        filename,
        mode="exec",
        type_comments=type_comments,
        feature_version=feature_version,
    )


def iter_call_args(node: ast.Call) -> typing.Iterator[typing.Any]:
    for arg in node.args:
        yield get_node_value(arg)


def iter_node_type(
    node: ast.AST,
    node_classinfo: typing.Union[
        typing.Type[T_AST], typing.Tuple[typing.Type[T_AST], ...]
    ],
) -> typing.Iterator[T_AST]:
    for descendant in ast.walk(node):
        if isinstance(descendant, node_classinfo):
            yield typing.cast(T_AST, descendant)


def get_node_value(node: ast.AST) -> typing.Any:
    if isinstance(node, ast.Constant):
        return node.value
    elif is_string_node(node):
        return get_string_node_value(node)
    elif isinstance(node, ast.Name):
        return UNKNOWN
    else:
        try:
            return ast.literal_eval(node)
        except (SyntaxError, ValueError, IndentationError):
            return UNKNOWN


def get_string_node_value(node: ast.AST) -> str:
    if isinstance(node, ast.BinOp) and isinstance(node.op, ast.Add):
        return get_string_node_value(node.left) + get_string_node_value(node.right)
    elif isinstance(node, ast.Constant) and isinstance(node.value, str):
        return node.s
    else:
        raise TypeError(f"Unexpected node type: {type(node)}")


def is_string_arith_expr(node: ast.AST) -> bool:
    """Returns True if `node` is `"a" + [... +] "z"`."""
    if not (isinstance(node, ast.BinOp) and isinstance(node.op, ast.Add)):
        return False

    return is_string_node(node.left) and is_string_node(node.right)


def is_string_node(node: ast.AST) -> bool:
    return (
        isinstance(node, ast.Constant) and isinstance(node.value, str)
    ) or is_string_arith_expr(node)


def iter_bases(node: ast.ClassDef) -> typing.Iterator[typing.Tuple[str, ...]]:
    for base_node in node.bases:
        if isinstance(base_node, (ast.Attribute, ast.Name)):
            yield tuple(iter_name(base_node))


def iter_name(node: ast.AST, reverse: bool = False) -> typing.Iterator[str]:
    if isinstance(node, ast.Name):
        yield node.id
    elif isinstance(node, ast.Attribute):
        if reverse:
            yield node.attr
            yield from iter_name(node.value, reverse=reverse)
        else:
            yield from iter_name(node.value, reverse=reverse)
            yield node.attr
    elif isinstance(node, ast.Call):
        yield from iter_name(node.func, reverse=reverse)
    elif isinstance(node, ast.Expr):
        yield from iter_name(node.value, reverse=reverse)


def iter_model_params(
    classdef_node: ast.ClassDef,
) -> typing.Iterator[typing.Tuple[str, ast.AST]]:
    def handle_assign(
        node: typing.Union[ast.Assign, ast.AnnAssign],
    ) -> typing.Iterator[typing.Tuple[str, typing.Any]]:
        if node.value is not None:
            targets = node.targets if isinstance(node, ast.Assign) else [node.target]
            for target in targets:
                if isinstance(target, ast.Name):
                    if target.id.startswith("_"):
                        yield target.id, node.value

    for node in classdef_node.body:
        if isinstance(node, (ast.Assign, ast.AnnAssign)):
            yield from handle_assign(node)


def get_model_name(params: typing.Dict[str, typing.Any]) -> typing.Optional[str]:
    _name = params.get("_name")
    if _name:
        return _name
    _inherit = params.get("_inherit")
    if _inherit:
        if isinstance(_inherit, list):
            # `_inherit = []`
            if len(_inherit) == 0:
                return None
            # `_inherit = ['foo']`
            elif len(_inherit) == 1:
                return _inherit[0]
            # `_inherit = ['foo', 'bar', ...]`, currently not supported.
            else:
                raise ValueError(
                    f"Unexpected number of `_inherit` models: {len(_inherit)}"
                )
        else:
            return _inherit
    return None
