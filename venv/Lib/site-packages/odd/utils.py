import operator
import pathlib
from typing import (
    Any,
    Dict,
    Callable,
    Iterable,
    Iterator,
    List,
    Mapping,
    Optional,
    Set,
    Tuple,
    Type,
    Union,
    TypeVar,
)

from odd.artifact.issue import Confidence, Issue, Severity
from odd.const import SUPPORTED_ODOO_VERSIONS

T_VersionSpec = TypeVar("T_VersionSpec", int, float)


def _resolve_path(path: pathlib.Path, working_dir: pathlib.Path) -> pathlib.Path:
    try:
        return path.relative_to(working_dir)
    except ValueError:
        return path.resolve()


def list_files(
    dir_path: pathlib.Path,
    *,
    list_dirs: bool = False,
    exclude_dirs: Optional[Iterable[pathlib.Path]] = None,
) -> Iterator[pathlib.Path]:
    exclude_dirs = set(exclude_dirs) if exclude_dirs else set()
    for path in dir_path.iterdir():
        if path.is_dir():
            if path in exclude_dirs:
                continue
            if list_dirs:
                yield path
            yield from list_files(path, list_dirs=list_dirs, exclude_dirs=exclude_dirs)
        else:
            yield path


def filter_issues(
    issues: Iterable[Issue],
    *,
    min_severity: Severity = Severity.NORMAL,
    min_confidence: Confidence = Confidence.MEDIUM,
) -> Iterator[Issue]:
    for issue in issues:
        if issue.severity < min_severity or issue.confidence < min_confidence:
            continue
        yield issue


def format_issue_locations(
    issue: Issue, working_dir: pathlib.Path, fixed_path: Optional[pathlib.Path] = None
) -> Iterator[str]:
    if issue.locations:
        for location in issue.locations:
            if fixed_path is not None and location.path != fixed_path:
                continue

            path = _resolve_path(location.path, working_dir)
            line_no, col_no = location.position if location.position else (None, None)
            position = ":".join(
                (
                    "" if line_no is None else f"{line_no}",
                    "" if col_no is None else f"{col_no}",
                )
            )
            yield f"{path!s}:{position}: {issue.description}"
    elif fixed_path is None:
        yield f"::: {issue.description}"


def _get_operator(
    version_spec: str, version_cls: Type[T_VersionSpec]
) -> Tuple[Callable[[Any, Any], bool], T_VersionSpec]:
    for prefix, op in (
        ("*", lambda a, b: bool(a)),
        ("<=", operator.le),
        ("<", operator.lt),
        (">=", operator.ge),
        (">", operator.gt),
        ("!=", operator.ne),
        ("!", operator.ne),
        ("==", operator.eq),
        ("=", operator.eq),
    ):
        if version_spec.startswith(prefix):
            return op, version_cls(version_spec[len(prefix) :])

    raise ValueError(f"Invalid version specification: {version_spec}")


def lookup_version_list(
    version_map: Mapping[str, Union[List[Any], Set[Any], Dict[Any, Any]]],
    version: int,
    *,
    result_cls=list,
) -> Union[List[Any], Set[Any], Dict[Any, Any]]:
    if not isinstance(version, int):
        raise TypeError(
            f"Invalid version, expected an integer, got {version} ({type(version)})"
        )
    if version not in SUPPORTED_ODOO_VERSIONS:
        raise ValueError(
            f'Unsupported version "{version}", must be one of {SUPPORTED_ODOO_VERSIONS}'
        )

    result = result_cls()
    if result_cls == list:
        extend = result.extend
    elif result_cls == set or result_cls == dict:
        extend = result.update
    else:
        raise TypeError(f"Unknown type for `result_cls`: {type(result_cls)}")
    for version_ranges, values in version_map.items():
        all_matched = True
        for version_spec in version_ranges.split(","):
            op, v2 = _get_operator(version_spec, version_cls=int)
            if not op(version, v2):
                all_matched = False
                break

        if all_matched:
            extend(values)
    return result


def expand_version_list(
    version_map: Mapping[str, Union[List[Any], Set[Any], Dict[Any, Any]]],
    *versions: int,
    result_cls=list,
) -> Dict[int, Union[List[Any], Set[Any], Dict[Any, Any]]]:
    result = {}
    for version in versions:
        result[version] = lookup_version_list(
            version_map, version, result_cls=result_cls
        )
    return result


def split_external_id(external_id: str) -> Tuple[Optional[str], str]:
    if not external_id:
        raise ValueError(
            f'Expected non-empty string, got: "{external_id}"'
            f" (type: {type(external_id)})"
        )
    addon_name, record_id = None, external_id
    parts = [p.strip() for p in external_id.split(".")]
    if len(parts) > 2 or len(parts) == 2 and not all(parts):
        raise ValueError(f"Invalid external ID: {external_id}")
    elif len(parts) == 2:
        addon_name, record_id = parts
    return addon_name, record_id


def split_groups(groups: str) -> Iterator[str]:
    for group in groups.split(","):
        yield group.strip().lstrip("-!")


def remove_old_style_format(s: str) -> str:
    return s[2:-2] if s.startswith("%(") and s.endswith((")d", ")s")) else s
