import ast
import typing

from odd.artifact import AddonPath, FieldDefinition, ModelDefinition, PythonModule
from odd.ast_utils import (
    get_model_name,
    get_node_value,
    iter_model_params,
    iter_name,
    parse,
    search_in_scope,
)
from odd.const import SUPPORTED_ODOO_VERSIONS
from odd.plugin import Plugin
from odd.utils import expand_version_list

FIELD_TYPE_VERSION_MAP = expand_version_list(
    {
        ">=8": {
            "Binary",
            "Boolean",
            "Char",
            "Date",
            "Datetime",
            "Float",
            "Html",
            "Id",
            "Integer",
            "Many2many",
            "Many2one",
            "One2many",
            "Reference",
            "Selection",
            "Serialized",
            "Text",
        },
        ">=9": {"Monetary"},
        ">=13": {"Image", "Many2oneReference"},
    },
    *SUPPORTED_ODOO_VERSIONS,
    result_cls=set,
)


class PythonEmitter(Plugin):
    _handles = {"addon_path"}
    _emits = {"python_module"}

    def on_addon_path(self, addon_path: AddonPath):
        if addon_path.path.suffix != ".py":
            return
        with addon_path.path.open(mode="rb") as f:
            node = parse(addon_path.addon.odoo_version, f.read())
        yield PythonModule(addon_path.addon, addon_path.path, node)


class ModelDefinitionEmitter(Plugin):
    _handles = {"python_module"}
    _emits = {"model_definition"}

    def on_python_module(self, python_module: PythonModule):
        for classdef in search_in_scope(python_module.node, ast.ClassDef):
            model_params = {
                name: get_node_value(node) for name, node in iter_model_params(classdef)
            }

            if not get_model_name(model_params):
                continue

            yield ModelDefinition(
                addon=python_module.addon,
                path=python_module.path,
                node=classdef,
                class_name=classdef.name,
                params=model_params,
            )


class FieldDefinitionEmitter(Plugin):
    _handles = {"model_definition"}
    _emits = {"field_definition"}

    def on_model_definition(self, model: ModelDefinition):
        field_types = FIELD_TYPE_VERSION_MAP[model.addon.odoo_version]

        def handle_assign(node: typing.Union[ast.Assign, ast.AnnAssign]):
            targets = node.targets if isinstance(node, ast.Assign) else [node.target]
            names = [t.id for t in targets if isinstance(t, ast.Name)]

            field_node = node.value
            if not names or not field_node or not isinstance(field_node, ast.Call):
                return

            name_parts = tuple(iter_name(field_node))
            if not name_parts or len(name_parts) > 3:
                return

            if len(name_parts) == 3 and (
                name_parts[0] not in ("odoo", "openerp") or name_parts[1] != "fields"
            ):
                return
            elif len(name_parts) == 2 and name_parts[0] != "fields":
                return

            field_class = name_parts[-1]

            # E.g. `foo = Someclass()``. Since we have no extra ways to
            # check if `Someclass` is a field, skip this case.
            if len(name_parts) == 1 and field_class not in field_types:
                return

            for name in names:
                yield FieldDefinition(
                    node=field_node, name=name, class_name=field_class, model=model
                )

        for node in model.node.body:
            if isinstance(node, (ast.Assign, ast.AnnAssign)):
                yield from handle_assign(node)
