import ast
import collections
import pathlib
import typing

from odd.artifact import (
    Addon,
    CSVRow,
    ExternalID,
    ExternalIDReference,
    FieldDefinition,
    Location,
    ModelDefinition,
    Position,
    PythonModule,
    XMLDocument,
)
from odd.ast_utils import (
    ASTNodePosition,
    get_string_node_value,
    is_string_node,
    iter_call_args,
    iter_model_params,
    iter_name,
    iter_node_type,
    parse,
    search_in_scope,
)
from odd.const import SUPPORTED_ODOO_VERSIONS, UNKNOWN
from odd.plugin import Plugin
from odd.utils import (
    expand_version_list,
    remove_old_style_format,
    split_external_id,
    split_groups,
)

XML_OPERATION_VERSION_MAP = expand_version_list(
    {
        ">=8": [
            "record",
            "menuitem",
            "act_window",
            "report",
            "template",
            "delete",
            "function",
        ]
    },
    *SUPPORTED_ODOO_VERSIONS,
    result_cls=list,
)
KNOWN_FIELD_MODELS = {
    "ir.rule": {"model_id": "ir.model"},
    "ir.ui.view": {"inherit_id": "ir.ui.view"},
}
SELECTION_NODES = SQL_CONSTRAINT_NODES = ast.List, ast.Tuple
FIELD_DECORATORS = "onchange", "constrains", "depends"


def _get_view_arch(record):
    for field in record.iterchildren(tag="field"):
        if field.get("name") == "arch":
            return field
    return None


def _csv_split_external_id(s: str) -> typing.Iterator[str]:
    if not s:
        return
    for external_id in s.split(","):
        external_id = external_id.strip()
        if external_id:
            yield external_id


def _model_record_id(model: str) -> str:
    return f"model_{model.replace('.', '_')}"


def _field_record_id(odoo_version: int, model: str, field_name: str) -> str:
    if odoo_version < 12:
        return f"field_{model.replace('.', '_')}_{field_name}"
    else:
        return f"field_{model.replace('.', '_')}__{field_name}"


def _selection_key_id(model: str, field_name: str, value: str) -> str:
    # Source: https://git.io/JeoRn
    value = value.replace(".", "_").replace(" ", "_").lower()
    return f"selection__{model}__{field_name}__{value}"


def _constraint_id(model: str, name: str) -> str:
    return f"constraint_{model.replace('.', '_')}_{name}"


def _ref(
    addon,
    filename,
    position: typing.Union[int, Position],
    external_id,
    model,
    unknown_addon=False,
) -> ExternalIDReference:
    addon_name, record_id = split_external_id(external_id)
    return ExternalIDReference(
        addon,
        UNKNOWN if unknown_addon else addon_name,
        record_id,
        model,
        Location(
            filename, Position(position) if isinstance(position, int) else position
        ),
    )


def _ref_or_def(
    addon, filename, position: typing.Union[int, Position], external_id, model
) -> typing.Union[ExternalID, ExternalIDReference]:
    addon_name, record_id = split_external_id(external_id)
    cls_ = ExternalIDReference
    if not addon_name or addon_name == addon.name:
        cls_ = ExternalID
    return cls_(
        addon,
        addon_name,
        record_id,
        model,
        Location(
            filename, Position(position) if isinstance(position, int) else position
        ),
    )


def _model_ref(addon, filename, position, model_name: str) -> ExternalIDReference:
    return _ref(
        addon,
        filename,
        position,
        _model_record_id(model_name),
        "ir.model",
        unknown_addon=True,
    )


def _ref_getter(_, args: typing.Iterator[typing.Any]) -> typing.Iterator[str]:
    first_arg = next(args, None)
    if first_arg and isinstance(first_arg, str):
        yield first_arg


def _user_has_groups_getter(
    _, args: typing.Iterator[typing.Any]
) -> typing.Iterator[str]:
    first_arg = next(args, None)
    if first_arg and isinstance(first_arg, str):
        yield from split_groups(first_arg)


def _for_xml_id_getter(
    odoo_version: int, args: typing.Iterator[typing.Any]
) -> typing.Iterator[str]:
    addon_name, record_id = next(args, None), next(args, None)
    if (
        addon_name
        and record_id
        and isinstance(addon_name, str)
        and isinstance(record_id, str)
    ):
        yield f"{addon_name}.{record_id}"


_REF_CHECK_MAP, MAX_REF_NAME_LENGTH = {}, 0
for names, getter, model in (
    ((".env.ref", ".self.ref", ".self.browse_ref"), _ref_getter, UNKNOWN),
    ((".has_group",), _ref_getter, "res.groups"),
    ((".user_has_groups",), _user_has_groups_getter, "res.groups"),
    ((".for_xml_id",), _for_xml_id_getter, "ir.actions.act_window"),
):
    for name in names:
        _REF_CHECK_MAP[name] = getter, model

        dot_count = name.count(".")
        if dot_count > MAX_REF_NAME_LENGTH:
            MAX_REF_NAME_LENGTH = dot_count


def _iter_selection_keys(
    node: typing.Union[ast.List, ast.Tuple]
) -> typing.Iterator[typing.Tuple[str, Position]]:
    for pair in node.elts:
        if (
            isinstance(pair, SELECTION_NODES)
            and len(pair.elts) == 2
            and is_string_node(pair.elts[0])
        ):
            yield get_string_node_value(pair.elts[0]), ASTNodePosition.from_node(
                pair.elts[0]
            ).start_pos_col_1


class ExternalIDEmitter(Plugin):
    _handles = {
        "addon",
        "xml_document",
        "python_module",
        "model_definition",
        "field_definition",
        "csv_row",
    }
    _emits = {"external_id", "external_id_reference", "python_module"}

    def __init__(self):
        super().__init__()

        # A cache map of `pathlib.Path` -> {external IDs field names} to not compute
        # the field names repeatedly for each row in a file.
        self._csv_external_id_fields: typing.DefaultDict[
            pathlib.Path, typing.Set[str]
        ] = collections.defaultdict(set)

    def _extract_xml_record(self, addon, filename, tree):
        # <record> operation.
        for record in tree.xpath("//record"):
            record_model, record_id = record.attrib["model"], record.get("id")
            if record_model:
                yield _model_ref(addon, filename, record.sourceline, record_model)
            if record_id:
                yield _ref_or_def(
                    addon, filename, record.sourceline, record_id, record_model
                )

            # <field> operation.
            for field in record.iterchildren(tag="field"):
                field_name = field.attrib["name"]

                field_external_id = _field_record_id(
                    addon.odoo_version, record_model, field_name
                )
                yield ExternalIDReference(
                    addon,
                    UNKNOWN,
                    field_external_id,
                    "ir.model.fields",
                    Location(filename, Position(field.sourceline)),
                )

                ref = field.get("ref")
                if ref:
                    ref_model = KNOWN_FIELD_MODELS.get(record_model, {}).get(
                        field_name, UNKNOWN
                    )
                    yield _ref(addon, filename, field.sourceline, ref, ref_model)

                for attr_name in ("eval", "search"):
                    yield from self._get_ref_from_eval(
                        addon, filename, field.sourceline, field.get(attr_name)
                    )

            # View-specific tags.
            if record_model != "ir.ui.view":
                continue

            arch = _get_view_arch(record)
            if arch is None:
                continue

            for button in arch.xpath(".//button[@type='action' and @name]"):
                button_name = button.get("name")
                if button_name:
                    yield _ref(
                        addon,
                        filename,
                        button.sourceline,
                        remove_old_style_format(button_name),
                        # Find out if we can have a model here.
                        UNKNOWN,
                    )

            for el in arch.xpath(".//*[@groups]"):
                groups = el.get("groups")
                for group in split_groups(groups):
                    yield _ref(addon, filename, el.sourceline, group, "res.groups")

    def _extract_xml_menuitem(self, addon, filename, tree):
        # <menuitem> shortcut.
        for menuitem in tree.xpath("//menuitem"):
            yield _ref_or_def(
                addon,
                filename,
                menuitem.sourceline,
                menuitem.attrib["id"],
                "ir.ui.menu",
            )
            parent = menuitem.get("parent")
            if parent:
                yield _ref(addon, filename, menuitem.sourceline, parent, "ir.ui.menu")

            action = menuitem.get("action")
            if action:
                yield _ref(
                    addon,
                    filename,
                    menuitem.sourceline,
                    action,
                    "ir.actions.act_window",
                )

            groups = menuitem.get("groups")
            if groups:
                for group in split_groups(groups):
                    yield _ref(
                        addon, filename, menuitem.sourceline, group, "res.groups"
                    )

    def _extract_xml_act_window(self, addon, filename, tree):
        # <act_window> shortcut.
        for act_window in tree.xpath("//act_window"):
            yield _ref_or_def(
                addon,
                filename,
                act_window.sourceline,
                act_window.attrib["id"],
                "ir.actions.act_window",
            )

            groups = act_window.get("groups")
            if groups:
                for group in split_groups(groups):
                    yield _ref(
                        addon, filename, act_window.sourceline, group, "res.groups"
                    )

            view_id = act_window.get("view_id")
            if view_id:
                yield _ref(
                    addon, filename, act_window.sourceline, view_id, "ir.ui.view"
                )

            res_model = act_window.get("res_model")
            if res_model:
                yield _model_ref(addon, filename, act_window.sourceline, res_model)

            src_model = act_window.get("src_model")
            if src_model:
                yield _model_ref(addon, filename, act_window.sourceline, src_model)

    def _extract_xml_report(self, addon, filename, tree):
        # <report> shortcut.
        for report in tree.xpath("//report"):
            # TODO: `name`, `file`?
            yield _ref_or_def(
                addon,
                filename,
                report.sourceline,
                report.attrib["id"],
                "ir.actions.report",
            )

            name = report.get("name")
            if name and "rml" not in report.attrib:
                yield _ref(addon, filename, report.sourceline, name, "ir.ui.view")

            paperformat_id = report.get("paperformat")
            if paperformat_id and addon.odoo_version > 8:
                yield _ref(
                    addon,
                    filename,
                    report.sourceline,
                    paperformat_id,
                    "report.paperformat",
                )

            model = report.get("model")
            if model:
                yield _model_ref(addon, filename, report.sourceline, model)

            groups = report.get("groups")
            if groups:
                for group in split_groups(groups):
                    yield _ref(addon, filename, report.sourceline, group, "res.groups")

    def _extract_xml_template(self, addon, filename, tree):
        # <template> shortcut.
        for template in tree.xpath("//template"):
            template_id = template.get("id")
            if template_id:
                yield _ref_or_def(
                    addon, filename, template.sourceline, template_id, "ir.ui.view"
                )

            inherit_id = template.get("inherit_id")
            if inherit_id:
                yield _ref(
                    addon, filename, template.sourceline, inherit_id, "ir.ui.view"
                )

            groups = template.get("groups")
            if groups:
                for group in split_groups(groups):
                    yield _ref(
                        addon, filename, template.sourceline, group, "res.groups"
                    )

    def _extract_xml_delete(self, addon, filename, tree):
        # <delete> operation.
        for delete in tree.xpath("//delete"):
            search = delete.get("search")
            if search:
                yield from self._get_ref_from_eval(
                    addon, filename, delete.sourceline, search
                )

            model = delete.get("model")
            if model:
                yield _model_ref(addon, filename, delete.sourceline, model)

            record_id = delete.get("id")
            if record_id:
                yield _ref(
                    addon,
                    filename,
                    delete.sourceline,
                    record_id,
                    UNKNOWN if model is None else model,
                )

    def _extract_xml_function(self, addon, filename, tree):
        # <function> operation.
        for function in tree.xpath("//function"):
            model = function.get("model")
            if model:
                yield _model_ref(addon, filename, function.sourceline, model)

            eval_ = function.get("eval")
            if eval_:
                yield from self._get_ref_from_eval(
                    addon, filename, function.sourceline, eval_
                )

            for value in function.iterchildren(tag="value"):
                eval_ = value.get("eval")
                if eval_:
                    yield from self._get_ref_from_eval(
                        addon, filename, value.sourceline, eval_
                    )

    def _get_ref_from_eval(self, addon, filename, position, eval_value):
        if not eval_value or eval_value in ("True", "False", "1", "0"):
            return

        module = parse(addon.odoo_version, eval_value)
        for node in iter_node_type(module, ast.Call):
            if next(iter_name(node.func, reverse=True), None) != "ref":
                continue

            if len(node.args) == 1 and is_string_node(node.args[0]):
                ref = get_string_node_value(node.args[0])
                if ref:
                    yield _ref(addon, filename, position, ref, UNKNOWN)

    def _extract_selection_field(self, model_name: str, field: FieldDefinition):
        selection_found = False

        def from_collection(node: typing.Union[ast.List, ast.Tuple]):
            for key, position in _iter_selection_keys(node):
                yield ExternalID(
                    field.model.addon,
                    field.model.addon.name,
                    _selection_key_id(model_name, field.name, key),
                    "ir.model.fields.selection",
                    Location(field.model.path, position),
                )

        for kw in field.node.keywords:
            if kw.arg in ("selection", "selection_add") and isinstance(
                kw.value, SELECTION_NODES
            ):
                selection_found = True
                yield from from_collection(kw.value)
        if (
            not selection_found
            and field.node.args
            and isinstance(field.node.args[0], SELECTION_NODES)
        ):
            yield from from_collection(field.node.args[0])

    def _extract_sql_constraint(self, model_name: str, model: ModelDefinition):
        for name, node in iter_model_params(model.node):
            if name != "_sql_constraints" or not isinstance(node, SQL_CONSTRAINT_NODES):
                continue
            for constraint in node.elts:
                if (
                    isinstance(constraint, SQL_CONSTRAINT_NODES)
                    and len(constraint.elts) == 3
                    and is_string_node(constraint.elts[0])
                ):
                    constraint_name = get_string_node_value(constraint.elts[0])
                    position = ASTNodePosition.from_node(
                        constraint.elts[0]
                    ).start_pos_col_1
                    yield ExternalID(
                        model.addon,
                        model.addon.name,
                        _constraint_id(model_name, constraint_name),
                        "ir.model.constraint",
                        Location(model.path, position),
                    )

    def _extract_decorator_node(
        self, model_name: str, model: ModelDefinition, node: ast.Call
    ):
        decorator_name = next(iter_name(node.func, reverse=True), None)

        if decorator_name not in FIELD_DECORATORS and decorator_name != "returns":
            return

        if (
            decorator_name == "returns"
            and len(node.args) >= 1
            and is_string_node(node.args[0])
        ):
            model_name = get_string_node_value(node.args[0])
            if model_name != "self":
                yield _model_ref(
                    model.addon,
                    model.path,
                    ASTNodePosition.from_node(node.args[0]).start_pos_col_1,
                    model_name,
                )
                return

        for arg in node.args:
            if not is_string_node(arg):
                continue
            field_name = get_string_node_value(arg).split(".")[0]
            if field_name:
                yield ExternalIDReference(
                    model.addon,
                    UNKNOWN,
                    _field_record_id(model.addon.odoo_version, model_name, field_name),
                    "ir.model.fields",
                    Location(
                        model.path, ASTNodePosition.from_node(arg).start_pos_col_1
                    ),
                )

    def on_addon(self, addon: Addon):
        # This is a special case, automatically created for all addons:
        # https://git.io/JeqKX.
        yield ExternalID(
            addon,
            "base",
            f"module_{addon.name}",
            "ir.module.module",
            Location(addon.path),
        )

    def on_xml_document(self, xml_document: XMLDocument):
        for op in XML_OPERATION_VERSION_MAP[xml_document.addon.odoo_version]:
            yield from getattr(self, f"_extract_xml_{op}")(
                xml_document.addon, xml_document.path, xml_document.node
            )

    def on_python_module(self, python_module: PythonModule):
        odoo_version = python_module.addon.odoo_version

        # TODO: Add support if external ID was passed via `kwargs`.
        for call in iter_node_type(python_module.node, ast.Call):
            found, length, current = False, 0, ""
            for name_part in iter_name(call.func, reverse=True):
                length += 1
                if length > MAX_REF_NAME_LENGTH:
                    break

                current = f".{name_part}{current}"
                if current in _REF_CHECK_MAP:
                    found = True
                    position = ASTNodePosition.from_node(call.func).end_pos_col_1
                    getter, model = _REF_CHECK_MAP[current]
                    for ref_value in getter(odoo_version, iter_call_args(call)):
                        yield _ref(
                            python_module.addon,
                            python_module.path,
                            position,
                            ref_value,
                            model,
                        )

                # We found our match, no point in continuing.
                if found:
                    break

    def on_model_definition(self, model: ModelDefinition):
        # TODO: Emit magic field definitions if the model is a new one: `id`,
        # `display_name`, `__last_update`.
        # If `_log_access` is not False, emit `create_uid`, `create_date`,
        # `write_uid`, `write_date` as well. Source: https://git.io/JenCN.
        # TODO: If model has `_inherit`, emit model references for each model.
        model_name = model.name
        if model_name and model_name is not UNKNOWN:
            yield _ref_or_def(
                model.addon,
                model.path,
                model.position.start_pos_col_1,
                _model_record_id(model_name),
                "ir.model",
            )

            if model.addon.odoo_version >= 13:
                yield from self._extract_sql_constraint(model_name, model)

            for funcdef in search_in_scope(model.node, ast.FunctionDef):
                for decorator_node in funcdef.decorator_list:
                    if isinstance(decorator_node, ast.Call):
                        yield from self._extract_decorator_node(
                            model_name, model, decorator_node
                        )

    def on_field_definition(self, field: FieldDefinition):
        # TODO: If an existing field is being modified, emit field reference of the
        # existing field.
        model, model_name = field.model, field.model.name
        if model_name and model_name is not UNKNOWN:
            yield _ref_or_def(
                model.addon,
                model.path,
                field.position.start_pos_col_1,
                _field_record_id(model.addon.odoo_version, model_name, field.name),
                "ir.model.fields",
            )

            # Starting with Odoo 13, extract selection and reference keys.
            if field.model.addon.odoo_version >= 13 and field.class_name in (
                "Selection",
                "Reference",
            ):
                yield from self._extract_selection_field(model_name, field)

    def on_csv_row(self, csv_row: CSVRow):
        model = csv_row.path.stem
        addon, path, row = csv_row.addon, csv_row.path, csv_row.row

        yield ExternalIDReference(
            addon, UNKNOWN, _model_record_id(model), "ir.model", Location(path)
        )

        if path not in self._csv_external_id_fields:
            for field_name in row:
                if (
                    field_name.split(":")[-1] == "id"
                    or field_name.split("/")[-1] == "id"
                ):
                    self._csv_external_id_fields[path].add(field_name)

                # Add references to fields from the CSV file header.
                field_external_id = _field_record_id(
                    addon.odoo_version,
                    model,
                    (
                        field_name[:-3]
                        if field_name.endswith((":id", "/id"))
                        else field_name
                    ),
                )
                yield ExternalIDReference(
                    addon,
                    UNKNOWN,
                    field_external_id,
                    "ir.model.fields",
                    Location(path, Position(1)),
                )

        for field_name in self._csv_external_id_fields[path]:
            # TODO: Add support for KNOWN_FIELD_MODELS.
            for external_id in _csv_split_external_id(csv_row.row[field_name]):
                addon_name, record_id = split_external_id(external_id)
                cls_ = ExternalID if field_name == "id" else ExternalIDReference
                yield cls_(
                    csv_row.addon,
                    addon_name,
                    record_id,
                    model if field_name == "id" else UNKNOWN,
                    Location(csv_row.path, Position(csv_row.line_no)),
                )
